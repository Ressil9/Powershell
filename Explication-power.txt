ğŸ§© SECTION 1 : DÃ©claration des paramÃ¨tres et gestion initiale
Param(
    [Parameter(Mandatory = $false)] [string] $xmlFilesPath,
    [Parameter(Mandatory = $false)] [string] $archivesFolderPath
)

ğŸ§  Explication :

Param(...) â†’ DÃ©finit les paramÃ¨tres dâ€™entrÃ©e du script PowerShell.

[Parameter(Mandatory = $false)] â†’ Indique que ce paramÃ¨tre nâ€™est pas obligatoire.
(Si on le met Ã  $true, PowerShell obligerait lâ€™utilisateur Ã  fournir la valeur en ligne de commande.)

[string] â†’ Le type attendu : ici une chaÃ®ne de caractÃ¨res.

$xmlFilesPath â†’ Chemin vers le dossier contenant les fichiers XML (ou .rxlog.data) Ã  traiter.

$archivesFolderPath â†’ Chemin vers le dossier dâ€™archives oÃ¹ seront dÃ©placÃ©s les fichiers aprÃ¨s traitement.

ğŸ§© En rÃ©sumÃ© :
â†’ Si tu lances le script sans arguments, il utilisera les valeurs par dÃ©faut du fichier config.json.
â†’ Si tu veux surcharger, tu peux faire :

powershell .\readAndGetData.ps1 -xmlFilesPath "C:\data" -archivesFolderPath "C:\archives"









ğŸ§© SECTION 2 : DÃ©but du bloc Try global et import des modules
try {
    # â”€â”€â”€ Get All The Module We Need â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ".\src\*" | Get-ChildItem -include '*.psm1' | Import-Module -Force

ğŸ§  Explication :

try { ... } â†’ DÃ©marre un bloc de code surveillÃ© : sâ€™il y a une erreur, elle sera capturÃ©e par un catch.

Le commentaire # â”€â”€â”€ Get All The Module We Need â”€â”€â”€ indique que cette partie charge les modules nÃ©cessaires.

".\src\*" â†’ ReprÃ©sente le chemin oÃ¹ se trouvent les modules PowerShell (dans le dossier src).

Get-ChildItem -include '*.psm1' â†’ Liste tous les fichiers se terminant par .psm1, câ€™est-Ã -dire les modules PowerShell.

| Import-Module -Force â†’ Importe chaque module dans la session PowerShell.
-Force permet dâ€™Ã©craser une version dÃ©jÃ  chargÃ©e si elle existe.

ğŸ‘‰ Cela permet au script dâ€™utiliser des fonctions personnalisÃ©es comme write-log, buildEvent, sendDataToSplunk, etc.










ğŸ§© SECTION 3 : Variables globales et configuration de base
    $Global:exitCode = 0
    Set-Location $psScriptroot

ğŸ§  Explication :

$Global:exitCode = 0
â†’ Initialise un code de sortie global Ã  0, ce qui signifie succÃ¨s.
Ce code changera si une erreur survient (1 Ã  6 selon le type dâ€™erreur).

Set-Location $psScriptroot
â†’ Change le rÃ©pertoire de travail courant vers le dossier oÃ¹ se trouve le script PowerShell ($PSScriptRoot est une variable automatique contenant ce chemin).
Cela garantit que les chemins relatifs utilisÃ©s plus tard (ex: .\config\config.json) fonctionneront correctement.







ğŸ§© SECTION 4 : Lecture du fichier de configuration
    $config = Get-Content .\config\config.json -Raw | ConvertFrom-Json

ğŸ§  Explication :

Get-Content .\config\config.json â†’ Lit le contenu du fichier JSON de configuration.

-Raw â†’ Retourne le texte entier dâ€™un seul bloc (sinon il le renverrait ligne par ligne).

| ConvertFrom-Json â†’ Convertit ce texte JSON en objet PowerShell pour accÃ©der facilement aux propriÃ©tÃ©s :

$config.xmlFolder
$config.splunkToken
$config.apiLinkSplunk
â€¦









ğŸ§© SECTION 5 : DÃ©termination des chemins Ã  utiliser
    if ($archivesFolderPath) {
        $archivesFolder = $archivesFolderPath
    }
    else {
        $archivesFolder = $config.archivesFolder
    }

    if ($xmlFilesPath) {
        $xmlPath = $xmlFilesPath
    }
    else {
        $xmlPath = $config.xmlFolder
    }

    if ($config.dataExpirationTimeDay) {
        $timeToDelete = $config.dataExpirationTimeDay
    }

ğŸ§  Explication :

Ces if/else permettent de prioriser les paramÃ¨tres :

Si lâ€™utilisateur a fourni un chemin via la ligne de commande ($archivesFolderPath ou $xmlFilesPath), le script lâ€™utilise.

Sinon, il prend les valeurs du fichier config.json.

ğŸ§© Exemple :
Si tu as :

"archivesFolder": ".\\archives",
"xmlFolder": ".\\data"


et tu appelles :

powershell .\readAndGetData.ps1 -xmlFilesPath "D:\tests"


â†’ alors $xmlPath sera D:\tests, mais $archivesFolder restera .\archives.

$timeToDelete â†’ durÃ©e (en jours) avant de supprimer les anciens fichiers dâ€™archives (par ex. 60 jours).









ğŸ§© SECTION 6 : VÃ©rification des chemins
    if (!(Test-Path -path $xmlPath)) {
        throw "Error file or directory path does not exist: $xmlPath"
        $Global:exitCode = 6
    }

    if (!(Test-Path -path $archivesFolder)) {
        throw "Error file or directory path does not exist: $archivesFolder"
        $Global:exitCode = 6
    }

ğŸ§  Explication :

Test-Path â†’ VÃ©rifie si le chemin existe (fichier ou dossier).

!(...) â†’ NÃ©gation â†’ si le chemin nâ€™existe pas, on exÃ©cute le bloc.

throw "Error file or directory path does not exist: ..." â†’ Interrompt le script et dÃ©clenche une erreur critique.

$Global:exitCode = 6 â†’ DÃ©finit un code dâ€™erreur 6 = â€œincorrect file pathâ€.

ğŸ§© Cela empÃªche le script de continuer si les chemins configurÃ©s sont invalides.








ğŸ§© SECTION 7 : RÃ©cupÃ©ration des fichiers Ã  traiter
# get file in remote dir and exclude dir
$files = Get-ChildItem -Path $xmlPath | Where-Object { ! $_.PSIsContainer -and $_.Name -like "*.rxlog.data" }

ğŸ§  Explication ligne par ligne :

Get-ChildItem -Path $xmlPath
â†’ liste tous les Ã©lÃ©ments (fichiers + dossiers) du dossier indiquÃ© par $xmlPath.

| Where-Object { ... }
â†’ filtre ces Ã©lÃ©ments selon une condition.

! $_.PSIsContainer
â†’ exclut les rÃ©pertoires (PSIsContainer = $true pour les dossiers).
Donc on garde uniquement les fichiers.

-and $_.Name -like "*.rxlog.data"
â†’ ne garde que les fichiers dont le nom finit par .rxlog.data.

ğŸ§© RÃ©sultat :
$files contient tous les fichiers Ranorex de test Ã  analyser dans le dossier spÃ©cifiÃ© (ex. .\data).










ğŸ§© SECTION 8 : Lecture de la configuration Splunk
# splunk token to authentify
$splunkToken = $config.splunkToken

# link to Rest api of splunk
$apiLinkSplunk = $config.apiLinkSplunk

# Source for splunk data filtering
$splunkSource = $config.splunkSource

write-log -message "Found $($files.Count) files" -type "i"

ğŸ§  Explication :

$splunkToken â†’ contient le token dâ€™authentification pour Splunk (clÃ© API).

$apiLinkSplunk â†’ contient le lien de lâ€™API REST Splunk oÃ¹ les donnÃ©es seront envoyÃ©es.

$splunkSource â†’ dÃ©finit la â€œsourceâ€ que Splunk affichera pour ces Ã©vÃ©nements (utile pour filtrer dans les dashboards).

write-log -message ... -type "i"
â†’ fonction personnalisÃ©e (importÃ©e depuis les modules .psm1)
Elle enregistre un message dâ€™information (-type "i") dans les logs du script.
Ici, on indique combien de fichiers .rxlog.data ont Ã©tÃ© trouvÃ©s.




















ğŸ§© SECTION 9 : Boucle principale â€” traitement des fichiers
foreach ($file in $files) {
    write-log -message "Process file: $($file.name)" -type "i"

ğŸ§  Explication :

Le script boucle sur chaque fichier trouvÃ©.
$file contient des propriÃ©tÃ©s comme .FullName, .Name, .CreationTime, etc.
â†’ Pour chaque fichier, il va analyser le contenu XML et envoyer les donnÃ©es Ã  Splunk.

ğŸ”¹ Sous-section 9.1 : Lecture et parsing du fichier XML
try {
    [xml]$xmlContent = Get-Content $file.FullName


[xml] â†’ cast du contenu en objet XML PowerShell.

$xmlContent devient un objet structurÃ© (nÅ“uds, attributs, etc.), permettant dâ€™utiliser des sÃ©lecteurs XPath.

ğŸ”¹ Sous-section 9.2 : SÃ©lection des â€œtest casesâ€
$all_activities = $xmlContent.SelectNodes("//activity[@type='test-case']")
if ($all_activities.Count -eq 0) {
    throw "Nothing to process in this file"
}


SelectNodes("//activity[@type='test-case']") â†’ rÃ©cupÃ¨re tous les nÅ“uds <activity> ayant type="test-case".
Ce sont les tests individuels rÃ©alisÃ©s par Ranorex.

Si aucun test nâ€™est trouvÃ©, on interrompt le traitement de ce fichier.

ğŸ”¹ Sous-section 9.3 : Extraction des mÃ©tadonnÃ©es gÃ©nÃ©rales du fichier
write-log -message "Found $($all_activities.Count) test cases to parse" -type "i"

$computerHost = $($xmlContent.SelectSingleNode("//activity[@type='root']")).host
$environment = $($xmlContent.SelectSingleNode("//param[@name='Environment']/text()")).Value
$login = $($xmlContent.SelectSingleNode("//param[@name='Login']/text()")).Value
$timestamp = $($xmlContent.SelectSingleNode("//activity[@type='root']")).timestamp

ğŸ§  DÃ©tail :

//activity[@type='root'] â†’ le nÅ“ud racine du test (celui qui englobe tout).

.host et .timestamp â†’ lecture des attributs host et timestamp du test global.

Les deux lignes suivantes rÃ©cupÃ¨rent les paramÃ¨tres de test :

Environment (ex: PROD, TEST)

Login (nom dâ€™utilisateur qui a lancÃ© le test)

ğŸ”¹ Sous-section 9.4 : Nettoyage et rÃ©solution IP
if ($login) { $login = $login.Trim() }
if ($environment) { $environment = $environment.Trim() }

# â”€â”€â”€ Get The Ip Address From Dns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$adressIP = [System.Net.Dns]::GetHostAddresses($computerHost).ipaddresstostring[0]


.Trim() â†’ supprime les espaces autour du texte.

[System.Net.Dns]::GetHostAddresses() â†’ mÃ©thode .NET pour obtenir les adresses IP dâ€™un hÃ´te.

.ipaddresstostring[0] â†’ convertit en chaÃ®ne et prend la premiÃ¨re adresse IP trouvÃ©e.

ğŸ”¹ Sous-section 9.5 : Gestion des erreurs de parsing
} catch {
    Write-Log -message "An error has occurred while parsing the file $($file.Name)." -type "e" -returnCode "001"
    $Global:exitCode = 1
}


Si une erreur se produit (XML corrompu, balise manquante, etc.),
on enregistre un message dâ€™erreur (-type "e")
et on fixe le code dâ€™erreur global Ã  1.

















ğŸ§© SECTION 10 : Construction et envoi des Ã©vÃ©nements Splunk
ğŸ”¹ Sous-section 10.1 : Boucle sur chaque activitÃ© â€œtest-caseâ€
foreach ($activity in $all_activities) {
    $Global:result = @()
    try {
        buildEvent -environment $environment -xml $activity -timestamp $timestamp -IP $adressIP  -rid $activity.rid -videoFile $activity.videoFile -parentDisplayName $activity.displayName -parentType $activity.type -login $login -state ([string]$activity.result)
    }


ğŸ§  DÃ©tail :

$Global:result = @() â†’ initialise un tableau vide global (va contenir tous les Ã©vÃ©nements produits).

buildEvent (...) â†’ fonction personnalisÃ©e (importÃ©e depuis les modules).
Elle parcourt rÃ©cursivement les sous-activitÃ©s et construit un tableau dâ€™Ã©vÃ©nements structurÃ©s avec :

environment, timestamp, IP, rid, displayName, type, result, etc.

ğŸ”¹ Sous-section 10.2 : Gestion dâ€™erreur dans la construction
catch {
    $_
    Write-Log -message "An error occurred when constructing the event" -type "e" -returnCode "001"
    $Global:exitCode = 5
}


â†’ Si la fonction buildEvent Ã©choue, on log lâ€™erreur et on attribue le code 5 (â€œerror when building the eventsâ€).

ğŸ”¹ Sous-section 10.3 : Formatage et envoi Ã  Splunk
try {
    $body = $result | ForEach-Object {
        $finalParentPath = $_.parentPath
        if ($finalParentPath -eq "") { $finalParentPath = "root" }

        $el = @{
            parentPath  = $finalParentPath
            displayName = $_.displayName
            type        = $_.type
            durationms  = $_.durationms
            level       = $_.level
            rid         = $_.rid
            userName    = $_.userName
            IPaddress   = $_.IP
            environment = $_.environment
            result      = $_.result
            videoFile   = $_.videoFile
        }

        if ($_.errorMessage) {
            $el | Add-Member -NotePropertyName "errorMessage" -NotePropertyValue $_.errorMessage
        }

        @{
            "sourcetype" = "Ranorex_JSon"
            "source"     = $splunkSource
            "time"       = $_.time
            "event"      = $el
            "host"       = $computerHost
        } | ConvertTo-json -Depth 5 -Compress
    }

    write-log -message "send elements of the test case $($activity.displayName) to Splunk" -type "i"
    sendDataToSplunk -data $body -splunkserver $apiLinkSplunk -splunkToken $splunkToken

ğŸ§  Explication :

CrÃ©ation du corps JSON ($body)

On parcourt chaque Ã©lÃ©ment du tableau $result.

On construit une structure JSON compatible avec Splunk (sourcetype, source, event, host).

Chaque Ã©vÃ©nement contient les champs clÃ©s (durÃ©e, type, login, IP, etc.).

Ajout conditionnel

Si une activitÃ© contient une erreur (errorMessage), elle est ajoutÃ©e au JSON.

Conversion JSON

ConvertTo-Json -Depth 5 -Compress : convertit lâ€™objet PowerShell en chaÃ®ne JSON compacte.

Envoi

sendDataToSplunk est une fonction personnalisÃ©e qui appelle lâ€™API REST Splunk ($apiLinkSplunk) avec le token ($splunkToken) pour pousser les donnÃ©es.

ğŸ”¹ Sous-section 10.4 : Gestion des erreurs dâ€™envoi
catch {
    throw "Error occurred while sending the data to splunk : $($file.Name)."
    $Global:exitCode = 4
}


â†’ Si lâ€™envoi Ã©choue (connexion perdue, mauvais token, etc.), on arrÃªte tout et on fixe le code 4.

ğŸ”¹ Sous-section 10.5 : Archivage du fichier traitÃ©
write-log -message "Move file '$($file.Name)' to Archives directory" -type "i"
$dest = "$archivesFolder\$($file.Name)"

try {
    Move-Item -Path $file.FullName -Destination $dest -ErrorAction Stop
}
catch {
    $Global:exitCode = 2
    throw "Error occurred while moving the file $($file.Name)."
}


ğŸ§  Explication :

Une fois le fichier traitÃ©, il est dÃ©placÃ© vers le dossier dâ€™archives.

Move-Item effectue le dÃ©placement.

Si le dÃ©placement Ã©choue (ex. fichier verrouillÃ©), code dâ€™erreur 2.

ğŸ”¹ Sous-section 10.6 : Nettoyage des vieux fichiers
# delete all the files that are older than the date
try {
    $archivesFile = Get-ChildItem -Path $archivesFolder -Recurse -Include *.rxlog.data, *.png
    foreach ($archiveFile in $archivesFile) {
        $createdAtRelativeToToday = [math]::Floor(((Get-Date) - $archiveFile.CreationTime).TotalDays)
        if ($createdAtRelativeToToday -ge $timeToDelete) {
            Remove-Item -Path $archiveFIle -Force
        }
    }
}
catch {
    $Global:exitCode = 3
    throw "Error when deleting files"
}

ğŸ§  Explication :

On parcourt tous les fichiers .rxlog.data et .png dans les archives.

On calcule leur Ã¢ge en jours :

(Get-Date) - $archiveFile.CreationTime


Si le fichier est plus vieux que $timeToDelete (ex. 60 jours), il est supprimÃ©.

En cas dâ€™erreur (fichier protÃ©gÃ©, permission refusÃ©e), on fixe le code 3.

ğŸ”¹ Sous-section 10.7 : Code de sortie global
exit $Global:exitCode


â†’ Le script se termine en renvoyant le code de sortie final, ce qui permet Ã  un systÃ¨me externe (ex. un orchestrateur CI/CD) de savoir si tout sâ€™est bien passÃ©.